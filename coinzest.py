# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code
import hashlib
import math

from ccxt.base.exchange import Exchange

from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import AccountSuspended
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadResponse
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import NetworkError
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import InvalidNonce
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import NotSupported
from ccxt.base.errors import ArgumentsRequired
import time, base64, hmac, hashlib
import json



class coinzest(Exchange):
    def describe(self):
        return self.deep_extend(super(coinzest, self).describe(), {
            'id': 'coinzest',
            'name': 'coinzest',
            'countries': ['kr'],
            'rateLimit': 2000,
            'version': 'v1',
            'has': {
                'fetchBalance': True,
                'fetchMarkets': True,
                'createOrder': True,
                'cancelOrder': True,
                'fetchTicker': False,
                'fetchTrades': True,
                'fetchOHLCV': False,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOpenOrders': True,
                'fetchClosedOrders': False,
                'fetchCurrencies': False,
            },
            'timeframes': {
                '1m': '1min',
                '5m': '5min',
                '15m': '15min',
                '30m': '30min',
                '1h': '1hour',
                '1d': '1day',
                '1w': '1week',
            },
            'urls': {
                'logo': '',
                'api': 'https://api.coinzest.co.kr/api',
                'private_api': 'https://papi.coinzest.co.kr/api',
                'www': 'https://www.coinzest.co.kr/',
                'doc': 'https://api.coinzest.co.kr/#public-api-',
                'fees': '',
                'referral': '',
            },
            'api': {
                'public': {
                    'get': [
                        'public/coin',
                        'public/market',
                        'public/market_summary',
                    ],
                },
                'private': {
                    'get': [
                        'balances',
                        'orders',
                        'trades',
                        'assets',
                        'trading-pairs',
                        'order_info'
                    ],
                    'post': [
                        'orders',
                        'cancel_order'
                    ],
                    'delete': [
                        'orders'
                    ]
                },
            },
            'fees': {
                'funding': {
                    'withdraw': {
                    },
                },
                'trading': {
                    'maker': 0.000,
                    'taker': 0.000,
                },
            },
            'commonCurrencies': {
                'ENT': 'ENTCash',
            },
        })

    def fetch_markets(self, params={}):

        ret = self.public_get_public_market()
        markets = ret['list']

        result = []
        for market in markets:
            baseId = market['trdCoin']
            quoteId = market['mrkCoin']
            base = market['trdCoinName']
            quote = market['mrkCoinName']
            symbol = base + '/' + quote
            id = symbol
            active = True
            precision = {
                'amount': None,
                'price': None,
            }

            limits = {
                'amount': {
                    'min': None,
                    'max': None,
                },
                'price': {
                    'min': None,
                    'max': None,
                },
                'cost': {
                    'min': market['minTrdAmt'],
                    'max': None,
                },
            }
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': active,
                'tick_price': 0.01 if quote == 'KRW' else 0.00000001,
                'tick_amount': 0.00000001,
                'precision': precision,
                'limits': limits,
                'info': market,
            })
        return result

    def fetch_balance(self, page_size=200, page_num=1, params={}):
        self.load_markets()
        nonce = self.get_nonce()
        params = {
            'code': 'coin_balance'
        }
        response = self.request(path='',
                                api='private',
                                method='POST',
                                params=params)

        total = {}
        frees = {}
        useds = {}
        result = {}
        for asset in response['list']:
            if asset['trdCoin'] == '102':
                coin = ''
            else:
                coin = self.currencies_by_id[asset['trdCoin']]['code']
            f = 0
            u = 0
            t = float(asset['coinQty'])
            if t <= 0:
                continue
            coin = coin.upper()
            total[coin] = t
            frees[coin] = f
            useds[coin] = u
            result[coin] = {'free': f, 'used': u, 'total': t}
        result['total'] = total
        result['free'] = frees
        result['used'] = useds
        # result['info'] = response
        return result

    def fetch_trades(self, symbol, since=None, limit=None, params={}):
        self.load_markets()
        market = self.markets[symbol.upper()]
        path = 'public/recent_contract/' + market['quote'] + '-' + market['base']
        response = self.request(path=path, api='public', method='GET')

        if 'list' in response:
            return self.parse_trades(response['list'], market, since, limit)
        else:
            raise Exception('coinzest fetch_trade structure error: list not in response')

    def parse_trades(self, trades, market=None, since=None, limit=None):
        array = self.to_array(trades)
        array = [self.parse_trade(trade, market) for trade in array]
        array = self.sort_by(array, 'timestamp')
        symbol = market['symbol'] if market else None
        return self.filter_by_symbol_since_limit(array, symbol, since, limit)

    def parse_trade(self, trade, market):
        t = time.strptime(trade['contDt'], "%Y.%m.%d %H:%M:%S")
        timestamp = time.mktime(t) * 1000
        amount = self.safe_float(trade, 'contQty', 0)
        price = self.safe_float(trade, 'contPrc', 0)

        return {
            'info': trade,
            'id': 0,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'type': None,
            'side': None,
            'price': price,
            'amount': amount,
        }

    def fetch_order_book(self, symbol, limit=None, params={}):

        self.load_markets()
        market = self.markets[symbol.upper()]
        path = 'public/bid_price/' + market['quote'] + '-' + market['base']
        response = self.request(path=path, api='public', method='GET')

        if 'bid_price' in response:
            return self.parse_order_book(response['bid_price'], bids_key='bidList', asks_key='askList', price_key='price', amount_key='quantity')
        else:
            raise Exception('coinzest fetch_order_book sturcture error: bid_price not in response.')


    def parse_order(self, order, market=None):
        if order is None:
            raise ExchangeError(self.id + ' 获取订单数据为空')
        t = time.strptime(order['ordDate']+order['ordTime'], "%Y%m%d%H%M%S")
        timestamp = time.mktime(t) * 1000
        iso8601 = self.parse8601(timestamp=timestamp)
        price = self.safe_float(order, 'ordPrc')
        amount = self.safe_float(order, 'ordQty')
        remaining = self.safe_float(order, 'remaining', amount)
        average = 0
        filled = amount - remaining
        cost = self.safe_float(order, 'contQty')
        status = 'open'
        side = self.safe_string(order, 'side')
        return {
            'info': order,
            'id': self.safe_string(order, 'ordNum'),
            'timestamp': timestamp,
            'datetime': iso8601,
            'lastTradeTimestamp': timestamp,
            'symbol': market['symbol'],
            'type': 'limit',
            'side': side,
            'price': price,
            'cost': cost,
            'average': average,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': {'currency': '', 'cost': 0},
        }

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        assert(side in ['buy', 'sell'])
        assert(type in ['limit'])
        self.load_markets()
        nonce = self.get_nonce()
        market = self.markets[symbol]
        request = {
            'code': 'order_add',
            'mrkCoin': market['quoteId'],
            'trdCoin': market['baseId'],
            'itCd': 'BUY' if side == 'buy' else 'SEL',
            'ordPrcTpCd': 'LMT' if type == 'limit' else 'MKT',
            'qty': str(amount),
            'price': str(price),
            'nonce': nonce,
            'mktTotAmt': '0'
        }
        response = self.request(path='',
                                api='private',
                                method='POST',
                                params=request)

        now_ms = int(time.time() * 1000)
        ret = {
            'info': response,
            'id': self.safe_string(response, 'ordNum'),
            'timestamp': now_ms,
            'datetime': self.iso8601(now_ms),
            'lastTradeTimestamp': now_ms,
            'symbol': symbol,
            'type': 'limit',
            'side': side,
            'price': price,
            'cost': 0,
            'average': 0,
            'amount': amount,
            'filled': 0,
            'remaining': amount,
            'status': 'open',
            'fee': {'currency': '', 'cost': 0},
        }
        return ret

    def cancel_order(self, id, symbol, params):

        self.load_markets()
        nonce = self.get_nonce()
        market = self.markets[symbol]
        request = {
            'code': 'order_cancel',
            'mrkCoin': market['quoteId'],
            'trdCoin': market['baseId'],
            'itCd': 'BUY' if params['side'] == 'buy' else 'SEL',
            "ordPrcTpCd": "LMT",
            "qty": 0,
            'nonce': nonce,
            'orgOrdNum': id
        }
        response = self.request(path='',
                                api='private',
                                method='POST',
                                params=request)
        return response

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = self.markets[symbol]
        request = {
            "code": "order_info",
            'mrkCoin': market['quoteId'],
            'trdCoin': market['baseId'],
            "itCd": "SEL",
            "startDate": "20190724",
            "endDate": "20220725",
            "limit": "50",
            "page": "1"
        }
        response = self.request(path='',
                                api='private',
                                method='POST',
                                params=request)
        orders = self.parse_orders(orders=response['list'], market=market)
        for order in orders:
            order['side'] = 'sell'
        request = {
            "code": "order_info",
            'mrkCoin': market['quoteId'],
            'trdCoin': market['baseId'],
            "itCd": "BUY",
            "startDate": "20190724",
            "endDate": "20220725",
            "limit": "50",
            "page": "1"
        }
        response = self.request(path='',
                                api='private',
                                method='POST',
                                params=request)
        orders2 = self.parse_orders(orders=response['list'], market=market)
        for order in orders2:
            order['side'] = 'buy'
        orders += orders2
        return orders

    def fetch_my_trades(self, symbol=None, since=None, limit=50, params={}):
        self.load_markets()
        market = self.markets[symbol]
        request = {
            "code": "contract_info",
            'mrkCoin': market['quoteId'],
            'trdCoin': market['baseId'],
            "itCd": 'BUY' if params['side'] == 'buy' else 'SEL',
            "startDate": params['startDate'],
            "endDate": params['endDate'],
            "limit": limit,
            "page": params['page']
        }
        response = self.request(path='',
                                api='private',
                                method='POST',
                                params=request)

        trades = self.parse_my_trades(trades=response['list'], market=market)
        for trade in trades:
            trade['side'] = params['side']
        return trades

    def parse_my_trades(self, trades, market=None, since=None, limit=None):
        array = self.to_array(trades)
        array = [self.parse_my_trade(trade, market) for trade in array]
        array = self.sort_by(array, 'id')
        symbol = market['symbol'] if market else None
        return self.filter_by_symbol_since_limit(array, symbol, since, limit)

    def parse_my_trade(self, trade, market):
        t = time.strptime(trade['contDate'] + trade['contTime'], "%Y%m%d%H%M%S")
        timestamp = time.mktime(t) * 1000
        iso8601 = self.parse8601(timestamp=timestamp)
        amount = self.safe_float(trade, 'contQty', 0)
        price = self.safe_float(trade, 'contPrc', 0)
        cost = self.safe_float(trade, 'contAmt', 0)
        fee = {'cost': 0,
               'currency': '',
               'rate': 0}
        return {
            'info': trade,
            'id': self.safe_string(trade, 'contNum', ''),
            'timestamp': timestamp,
            'datetime': iso8601,
            'symbol': market['symbol'],
            'order': None,
            'type': None,
            'side': None,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee
        }

    def get_nonce(self):
        params = {
            'code': 'nonce'
        }
        response = self.request(path='',
                                api='private',
                                method='POST',
                                params=params)
        return response['nonce']

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        if api == 'public':
            url = self.urls['api'] + '/' + path
            if params:
                url += '?' + self.urlencode(params)
            return {'url': url, 'method': method, 'body': body, 'headers': headers}
        url = self.urls['private_api']
        self.check_required_credentials()
        params['key'] = self.apiKey
        params_json = json.dumps(params) if len(params) > 0 else ''
        params_json = params_json.replace(' ', '')
        what = self.secret + params_json
        check_sum = hashlib.sha256(what.encode('utf-8')).hexdigest()
        custom_headers = {
            'czChecksum': check_sum
        }

        if params:
            body = params_json
        result = {'url': url, 'method': method, 'body': body, 'headers': custom_headers}
        return result
